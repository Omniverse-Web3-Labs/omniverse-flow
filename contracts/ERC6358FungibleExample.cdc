import FungibleToken from "./utility/FungibleToken.cdc"
import MetadataViews from "./MetadataViews.cdc"
import ERC6358Protocol from "./ERC6358Protocol.cdc"
import IERC6358Token from "./IERC6358Token.cdc"
import BasicUtility from "./utility/BasicUtility.cdc";

pub contract ERC6358FungibleExample: FungibleToken, IERC6358Token {
    
    pub var totalSupply: UFix64;
    pub let flowChainID: UInt32;
    pub let contractName: String;

    pub let vaultStoragePath: StoragePath;
    pub let balancePublicPath: PublicPath;
    pub let ModifierPath: StoragePath;

    priv let transactionRecorder: {Address: ERC6358Protocol.RecordedCertificate};    // key is the address of a flow account, which is recorded in `ERC6358Protocol._pk2address_map`
    priv let TokenShelter: @{String: [ERC6358Protocol.ERC6358Wrapped]};          // Store pending tokens. The key is the recv address generated by `String.encodeHex(recver: [UInt8])`
    priv let Prisons: @{String: [ERC6358Protocol.ERC6358Wrapped]};               // Store punishment NFTs. The key is the operating address generated by `String.encodeHex(operator: [UInt8])`
    
    ////////////////////////////////////
    // Events for Omniverse Transactions
    pub event OmniverseTxEvent(pk: String, nonce: UInt128, result: Bool, description: String);      // Omniverse Transactions Information

    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Omniverse definations
    pub struct OmniFungiblePayload: IERC6358Token.IERC6358Payload {
        // 0: Omniverse Transfer
        // 1: Omniverse mint. When minting, the `tokenId` is useless
        // 2: Omniverse burn
        pub let operation: UInt8;
        pub let exData: [UInt8];

        pub let amount: UInt256;

        init(operation: UInt8, exData: [UInt8], amount: UInt256) {
            self.operation = operation;
            self.exData = exData;
            self.amount = amount;
        }

        pub fun toBytes(): [UInt8] {
            var output: [UInt8] = [];

            output.append(self.operation);
            output = output.concat(self.exData);
            output = output.concat(BasicUtility.to_be_bytes_u256(self.amount));

            return output;
        }
    }

    pub struct OmniFungibleProtocol: IERC6358Token.IERC6358TxProtocol {
        pub let nonce: UInt128;

        // The chain where the o-transaction is initiated
        pub let chainid: UInt32;
        // The contract address from which the o-transaction is first initiated
        // on Flow, this is concat by `account address`+`contract name`
        pub let initiateSC: String;
        // The Omniverse account which signs the o-transaction
        pub let from: [UInt8];

        pub let payload: AnyStruct{IERC6358Token.IERC6358Payload};

        pub let signature: [UInt8];

        init(nonce: UInt128, chainid: UInt32, initiateSC: String, from: [UInt8], payload: AnyStruct{IERC6358Token.IERC6358Payload}, signature: [UInt8]) {
            self.nonce = nonce;
            self.chainid = chainid;
            self.initiateSC = initiateSC;
            self.from = from;
            self.payload = payload;
            self.signature = signature;
        }

        // pub fun toBytesExceptNonce(): [UInt8];
        pub fun toBytes(): [UInt8] {
            var output: [UInt8] = [];

            output = output.concat(BasicUtility.to_be_bytes_u128(self.nonce));
            output = output.concat(self.chainid.toBigEndianBytes());
            output = output.concat(self.initiateSC.utf8);
            output = output.concat(self.from);
            output = output.concat(self.payload.toBytes());

            return output;
        }
        // pub fun getOperateIdentity(): [UInt8];
    }

    /// Vault
    ///
    /// The resource that contains the functions to send and receive tokens.
    ///
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, IERC6358Token.IERC6358Operation, IERC6358Token.IERC6358TokenExec {

        pub var balance: UFix64

        access(account) var lockedTime: UFix64;

        // The conforming type must declare an initializer
        // that allows prioviding the initial balance of the Vault
        //
        init(balance: UFix64) {
            self.balance = balance;
            self.lockedTime = 0.0;
        }

        /// withdraw subtracts `amount` from the Vault's balance
        /// and returns a new Vault with the subtracted balance
        ///
        pub fun withdraw(amount: UFix64): @Vault {
            panic("`withdraw` is deprecated in Omniverse Fungible Token");
        }

        /// deposit takes a Vault and adds its balance to the balance of this Vault
        ///
        pub fun deposit(from: @FungibleToken.Vault) {
            panic("`deposit` is deprecated in Omniverse Fungible Token");
        }

        pub fun sendOmniverseTransaction(otx: AnyStruct{IERC6358Token.IERC6358TxProtocol}) {
            panic("to be developed");
        }
        // pub fun getTransactionCount(pk: [UInt8]): UInt128;
        // pub fun getTransactionData(user: [UInt8], nonce: UInt128): OmniverseTxData;

        // Not in the `EIP-6358` standard, but necessary in Flow
        access(account) fun omniverseExec(omniToken: @AnyResource{IERC6358Token.IERC6358TokenExec}) {
            panic("to be developed");
        }

        // Vault as transferred assets
        access(account) fun setLockedTime() {
            self.lockedTime = getCurrentBlock().timestamp;
        }

        pub fun getLockedTime(): UFix64 {
            return self.lockedTime;
        }
    }

    pub resource Modifier {
        pub(set) var allowedMembers: {UInt32: String};               // value is generated by `String.encodeHex(contract address: [UInt8])`
        pub(set) var lockPeriod: UFix64;                             // In current version, there needs to be a wait time for omniverse transactions to be executed

        init(contractName: String) {
            self.allowedMembers = {ERC6358FungibleExample.flowChainID: ERC6358FungibleExample.contractName};
            self.lockPeriod = 60.0;
        }

        pub fun checkAllowed(chainID: UInt32, initiateSC: String): Bool {
            if let allowdSC = self.allowedMembers[chainID] {
                return allowdSC == initiateSC;
            } else {
                return false;
            }
        }
    }

    init() {
        self.totalSupply = 0.0;

        self.flowChainID = 7;
        self.contractName = self.account.address.toString().concat("ERC6358FungibleExample");

        self.vaultStoragePath = /storage/ERC6358FungibleExampleVault;
        self.balancePublicPath = /public/ERC6358FungibleExampleBalance;
        self.ModifierPath = /storage/ERC6358FungibleExampleModifier;

        self.transactionRecorder = {};
        self.TokenShelter <- {};
        self.Prisons <- {};

        self.account.save(<- create Modifier(contractName: self.contractName), to: self.ModifierPath);
    }

    /// createEmptyVault allows any user to create a new Vault that has a zero balance
    ///
    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0);
    }

    pub fun balanceOf(addr: Address): UFix64 {
        let cp = getAccount(addr).getCapability<&{FungibleToken.Balance}>(self.balancePublicPath);
        return cp.borrow()!.balance;
    }

    ////////////////////////////////////////////
    // getters
    pub fun getAllowedMembers(): {UInt32: String} {
        let modifier = self.account.borrow<&Modifier>(from: self.ModifierPath)!;
        return modifier.allowedMembers;
    }

    pub fun getLockPeriod(): UFix64 {
        let modifier = self.account.borrow<&Modifier>(from: self.ModifierPath)!;
        return modifier.lockPeriod;
    }

    pub fun getTransactionCount(pk: [UInt8]): UInt128 {
        let flowAddress = ERC6358Protocol.getFlowAddress(pubKey: pk);
        if let rc = self.transactionRecorder[flowAddress] {
            return rc.getTransactionCount();
        } else {
            return UInt128(0);
        }
    }

    pub fun getTransactionData(user: [UInt8], nonce: UInt128): AnyStruct{IERC6358Token.IERC6358TxData} {
        let flowAddress = ERC6358Protocol.getFlowAddress(pubKey: user);
        if let rc = self.transactionRecorder[flowAddress] {
            return rc.getTransactionData(nonce: nonce);
        }

        panic("Omniverse Transaction with nonce ".concat(nonce.toString()).concat(" does not exist!"));
    }

    pub fun getWorkingNonce(pk: [UInt8]): UInt128 {
        let flowAddress = ERC6358Protocol.getFlowAddress(pubKey: pk);

        if let rc = self.transactionRecorder[flowAddress] {
            return rc.getWorkingNonce();
        } else {
            return UInt128(0);
        }
    }

    ////////////////////////////////////////////
    // Public Omniverse Operations

    pub fun checkValid(opAddressOnFlow: Address): Bool {
        if let rc = (&self.transactionRecorder[opAddressOnFlow] as &ERC6358Protocol.RecordedCertificate?) {
            if rc.isMalicious() {
                panic("The address did malicious things and has been locked now!");
            }
        }

        return true;
    }

    ////////////////////////////////////////////
    // self functions
    priv fun _omniverseTxPublish(otx: AnyStruct{IERC6358Token.IERC6358TxProtocol}): Bool {
        // check initiate SC
        let modifier = self.account.borrow<&Modifier>(from: self.ModifierPath)!;
        if (!modifier.checkAllowed(chainID: otx.chainid, initiateSC: otx.initiateSC)) {
            panic("Invalid member!");
        }
        // check signature
        if (!ERC6358Protocol.rawSignatureVerify(pubKey: otx.from, rawData: otx.toBytes(), signature: otx.signature, hashAlgorithm: HashAlgorithm.KECCAK_256)) {
            panic("Invalid signature for the omniverse Tx");
        }

        let flowAddress = ERC6358Protocol.getFlowAddress(pubKey: otx.from);

        // check nonce
        if let ownerRC = (&self.transactionRecorder[flowAddress] as &ERC6358Protocol.RecordedCertificate?) {
            let workingNonce = ownerRC.getWorkingNonce();
            if (workingNonce == otx.nonce) {
                // current nonce
                // ownerRC.makeNextNonce();
                ownerRC.addTx(tx: ERC6358Protocol.OmniverseTxData(txData: otx));
            } else if (workingNonce > otx.nonce) {
                // history nonce
                return self._checkConflict(otx: otx, rc: ownerRC);
            } else {
                // future nonce
                panic("Invalid nonce. Related PK: ".concat(String.encodeHex(otx.from)));
            }
        } else {
            if (UInt128(0) == otx.nonce) {
                let rc = ERC6358Protocol.RecordedCertificate(addressOnFlow: flowAddress);
                rc.addTx(tx: ERC6358Protocol.OmniverseTxData(txData: otx))
                self.transactionRecorder[flowAddress] = rc;
            } else {
                panic("Invalid nonce. Related PK: ".concat(String.encodeHex(otx.from)));
            }
        }

        return true;
    }

    priv fun _checkConflict(otx: AnyStruct{IERC6358Token.IERC6358TxProtocol}, rc: &ERC6358Protocol.RecordedCertificate): Bool {
        let historyTx = rc.publishedTx[otx.nonce];
        if historyTx.txData.nonce != otx.nonce {
            panic("Nonce-index mechanism failed!");
        }

        let otxHash = String.encodeHex(HashAlgorithm.KECCAK_256.hash(otx.toBytes()));
        if (historyTx.hash == otxHash) {
            return true;
        } else {
            rc.setMalicious(historyTx: historyTx, currentTx: ERC6358Protocol.OmniverseTxData(txData: otx));
            // Here we will lock the @token added to `TokenShelter` in the past, so we need to use `historyTx.txData`
            self._lockedUpInPrison(otx: &historyTx.txData as! &AnyStruct{IERC6358Token.IERC6358TxProtocol});

            emit OmniverseTxEvent(pk: String.encodeHex(otx.from), nonce: otx.nonce, result: false, description: "Double Spend Attack!");
            return false;
        }
    }

    access(contract) fun _addPendingToken(nonce: UInt128, recvIdentity: [UInt8], token: @{IERC6358Token.IERC6358TokenExec}) {
        token.setLockedTime();

        let wrapped <- ERC6358Protocol.createWrapped6358(nonce: nonce, token: <- token);

        let recvStr = String.encodeHex(recvIdentity);
        if let shelter = (&self.TokenShelter[recvStr] as &[ERC6358Protocol.ERC6358Wrapped]?) {
            shelter.append(<- wrapped);
        } else {
            self.TokenShelter[recvStr] <-! [<-wrapped];
        }
    }

    priv fun _takeout(nonce: UInt128, container: &[ERC6358Protocol.ERC6358Wrapped]): @ERC6358Protocol.ERC6358Wrapped? {
        let count = container.length;
        var idx = 0;
        while idx < count {
            // let tempRef = &container[idx] as! auth &ERC6358Protocol.ERC6358Wrapped;

            if container[idx].nonce == nonce {
                return <- container.remove(at: idx);
            }
            
            idx = idx + 1;
        }

        return nil;
    }

    priv fun _lockedUpInPrison(otx: &AnyStruct{IERC6358Token.IERC6358TxProtocol}) {
        // The recver
        let recverStr = String.encodeHex(otx.payload.exData);
        // The malicious operator
        let opStr = String.encodeHex(otx.from);

        if let container = (&self.TokenShelter[recverStr] as &[ERC6358Protocol.ERC6358Wrapped]?) {
            if let token <- self._takeout(nonce: otx.nonce, container: container) {
                if let prisons = (&self.Prisons[opStr] as &[ERC6358Protocol.ERC6358Wrapped]?) {
                    prisons.append(<- token);
                } else {
                    self.Prisons[opStr] <-! [<- token];
                }
            }
        }
    }
}
