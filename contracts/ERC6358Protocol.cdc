/**
*   According to the standard at https://eips.ethereum.org/EIPS/eip-6358
*/ 

pub contract ERC6358Protocol {

    pub let IERC6358PathPrefix: String

    pub let SubmitterStoragePath: StoragePath
    pub let SubmitterPublicPath: PublicPath

    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    priv let _pk2address_map: {String: Address};

    pub resource interface IERC6358Operation {
        pub fun sendOmniverseTransaction(txData: AnyStruct{OmniverseTokenProtocol});
        // pub fun getTransactionCount(pk: [UInt8]): UInt128;
        // pub fun getTransactionData(user: [UInt8], nonce: UInt128): OmniverseTxData;

        // Not in the `EIP-6358` standard, but necessary in Flow
        access(account) fun omniverseExec(omniToken: @AnyResource{ERC6358Token});
    }

    pub resource interface ERC6358Token {
        access(account) var lockedTime: UFix64;

        access(account) fun setLockedTime() {
            post {
                self.lockedTime == getCurrentBlock().timestamp: 
                    panic("set locked time error!");
            }
        }

        pub fun getLockedTime(): UFix64;
    }

    pub struct interface ERC6358Payload {
        pub let exData: [UInt8];
        // 0: Omniverse Transfer
        // 1: Omniverse mint
        // 2: Omniverse burn
        pub let operation: UInt8;
    }

    pub struct interface OmniverseTokenProtocol {
        pub let nonce: UInt128;

        // The chain where the o-transaction is initiated
        pub let chainid: UInt32;
        // The contract address from which the o-transaction is first initiated
        // on Flow, this is concat by `account address`+``
        pub let initiateSC: String;
        // The Omniverse account which signs the o-transaction
        pub let from: [UInt8];

        pub let payload: AnyStruct{ERC6358Payload};

        pub let signature: [UInt8];

        // pub fun toBytesExceptNonce(): [UInt8];
        pub fun toBytes(): [UInt8];
        // pub fun getOperateIdentity(): [UInt8];
    }

    pub struct OmniverseTxData {
        pub let txData: AnyStruct{OmniverseTokenProtocol};
        pub let _time: UFix64;

        init(txData: AnyStruct{OmniverseTokenProtocol}) {
            self.txData = txData;
            self._time = getCurrentBlock().timestamp;
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Omniverse operation related definations
    pub struct RecordedCertificate {
        priv var nonce: UInt128;
        pub let addressOnFlow: Address;
        // The index of array `PublishedTokenTx` is related nonce,
        // that is, the nonce of a `PublishedTokenTx` instance is its index in the array
        pub let publishedTx: [OmniverseTxData];
        
        pub let evil: {UInt128: [OmniverseTxData]};

        init(addressOnFlow: Address) {
            self.nonce = 0;
            self.addressOnFlow = addressOnFlow;
            self.publishedTx = [];
            self.evil = {};
        }

        pub fun validCheck() {
            if self.isMalicious() {
                panic("Account: ".concat(self.addressOnFlow.toString()).concat(" has been locked as malicious things!"));
            }
        }

        pub fun getWorkingNonce(): UInt128 {
            return self.nonce + 1;
        }

        access(account) fun makeNextNonce() {
            self.validCheck();

            if self.nonce == UInt128.max {
                self.nonce = 0;
            } else {
                self.nonce = self.nonce + 1;
            }
        }

        access(account) fun addTx(tx: OmniverseTxData) {
            self.validCheck();

            if tx.txData.nonce != UInt128(self.publishedTx.length) {
                panic("Nonce error in transaction list! Address: ".concat(self.addressOnFlow.toString()));
            }

            self.publishedTx.append(tx);
        }

        pub fun getAllTx(): [OmniverseTxData] {
            return self.publishedTx;
        }

        pub fun getLatestTx(): OmniverseTxData? {
            let len = self.publishedTx.length;
            if len > 0 {
                return self.publishedTx[len - 1];
            } else if len == 0 {
                return nil;
            } else {
                panic("Invalid length");
            }
            return nil;
        }

        pub fun getLatestTime(): UFix64 {
            if let latestTx = self.getLatestTx() {
                return latestTx._time;
            } else {
                return 0.0;
            }
        }

        access(account) fun setMalicious(historyTx: OmniverseTxData, currentTx: OmniverseTxData) {
            if let evilRecord = (&self.evil[historyTx.txData.nonce] as &[OmniverseTxData]?) {
                evilRecord.append(currentTx);
            } else {
                self.evil[historyTx.txData.nonce] = [historyTx, currentTx];
            }
        }

        pub fun getEvils(): {UInt128: [OmniverseTxData]}{
            return self.evil;
        }

        pub fun isMalicious(): Bool {
            return self.evil.length > 0;
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////

    pub resource interface SubmitPublic {
        pub fun getSubmittedTx(): AnyStruct{OmniverseTokenProtocol};
    }

    pub resource TxSubmitter: SubmitPublic {
        priv var sTxData: AnyStruct{OmniverseTokenProtocol}?;

        init() {
            self.sTxData = nil;
        }

        pub fun setSubmittedTx(sTxData: AnyStruct{OmniverseTokenProtocol}) {
            self.sTxData = sTxData;
        }

        pub fun clearSubmittedTx() {
            self.sTxData = nil;
        }

        pub fun getSubmittedTx(): AnyStruct{OmniverseTokenProtocol} {
            return self.sTxData!;
        }
    }

    init() {
        self._pk2address_map = {};

        self.IERC6358PathPrefix = "IERC6358";

        self.SubmitterStoragePath = /storage/SubmitterPath;
        self.SubmitterPublicPath = /public/SubmitterPath;
    }

    pub fun getIERC6358Operation(addr: Address, contractName: String): &{IERC6358Operation} {
        let publicPath = PublicPath(identifier: ERC6358Protocol.IERC6358PathPrefix.concat(contractName))!;
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{IERC6358Operation}>(publicPath).borrow()!;
        return cpRef;
    }

    pub fun getSubmitterPublic(addr: Address): &{SubmitPublic} {
        let pubAcct = getAccount(addr);
        let submitterRef = pubAcct.getCapability<&{SubmitPublic}>(ERC6358Protocol.SubmitterPublicPath).borrow()!;
        return submitterRef;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // Core functions

    // signature verification without nonce update
    pub fun rawSignatureVerify(pubKey: [UInt8], rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {        
        let pk = PublicKey(publicKey: pubKey, 
                            signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

        return pk.verify(signature: signature,
                        signedData: rawData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm);
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    pub fun getPublicKey(address: Address, signatureAlgorithm: SignatureAlgorithm): PublicKey {
        let pubAcct = getAccount(address);
        let pk = PublicKey(publicKey: pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey, 
                            signatureAlgorithm: signatureAlgorithm);
        return pk;
    }

    pub fun activeOmniverse(addressOnFlow: Address) {
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        // check if `addressOnFlow` has valid `OmniverseNFT.Collection`
        // let cpRef = self.getCollectionPublic(addr: addressOnFlow);

        if !self._pk2address_map.containsKey(pkStr) {
            self._pk2address_map[pkStr] = addressOnFlow;
        }
    }

    pub fun getOmniverseIdentity(pubAddr: Address): [UInt8] {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        return pubKey.publicKey;
    }

    pub fun getFlowAddress(pubKey: [UInt8]): Address {
        let pkStr = String.encodeHex(pubKey);
        if let flowAddr = self._pk2address_map[pkStr] {
            return flowAddr;
        }

        panic("Cannot find the `pubKey` in the actived omniverse accounts!");
    }
}
