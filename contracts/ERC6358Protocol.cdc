/**
*   According to the standard at https://eips.ethereum.org/EIPS/eip-6358
*/ 

pub contract ERC6358Protocol {

    pub let IERC6358PathPrefix: String

    pub let SubmitterStoragePath: StoragePath
    pub let SubmitterPublicPath: PublicPath

    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    priv let _pk2address_map: {String: Address};

    pub let lockPeriod: UFix64;

    pub resource interface IERC6358Operation {
        pub fun sendOmniverseTransaction(txData: AnyStruct{OmniverseTokenProtocol});
        pub fun getTransactionCount(pk: [UInt8]): UInt128;
        pub fun getTransactionData(user: [UInt8], nonce: UInt128): SubmittedTxData;

        // Not in the `EIP-6358` standard, but necessary in Flow
        pub fun omniverseSettle(omniToken: @AnyResource{IERC6358Operation});
    }

    pub resource interface ERC6358TokenExec {
        access(account) var lockedTime: UFix64;

        access(account) fun setLockedTime() {
            post {
                self.lockedTime == getCurrentBlock().timestamp: 
                    panic("set locked time error!");
            }
        }

        pub fun getLockedTime(): UFix64;

        pub fun execution();
    }

    pub struct interface ERC6358Payload {
        pub let exData: [UInt8];
        // 0: Omniverse Transfer
        // 1: Omniverse mint
        // 2: Omniverse burn
        pub let operation: UInt8;
    }

    pub struct interface OmniverseTokenProtocol {
        pub let nonce: UInt128;

        // The chain where the o-transaction is initiated
        pub let chainid: UInt32;
        // The contract address from which the o-transaction is first initiated
        // on Flow, this is concat by `account address`+``
        pub let initiateSC: String;
        // The Omniverse account which signs the o-transaction
        pub let from: [UInt8];

        pub let payload: AnyStruct{ERC6358Payload};

        pub let signature: [UInt8];

        // pub fun toBytesExceptNonce(): [UInt8];
        pub fun toBytes(): [UInt8];
        // pub fun getOperateIdentity(): [UInt8];
    }

    pub struct SubmittedTxData {
        pub let txData: AnyStruct{OmniverseTokenProtocol};
        pub let _time: UInt64;

        init(txData: AnyStruct{OmniverseTokenProtocol}) {
            self.txData = txData;
            self._time = getCurrentBlock().height;
        }
    }

    pub resource interface SubmitPublic {
        pub fun getSubmittedTx(): SubmittedTxData;
    }

    pub resource TxSubmitter: SubmitPublic {
        priv var sTxData: SubmittedTxData?;

        init() {
            self.sTxData = nil;
        }

        pub fun setSubmittedTx(sTxData: SubmittedTxData) {
            self.sTxData = sTxData;
        }

        pub fun clearSubmittedTx() {
            self.sTxData = nil;
        }

        pub fun getSubmittedTx(): SubmittedTxData {
            return self.sTxData!;
        }
    }

    init() {
        self._pk2address_map = {};

        self.IERC6358PathPrefix = "IERC6358";

        self.SubmitterStoragePath = /storage/SubmitterPath;
        self.SubmitterPublicPath = /public/SubmitterPath;

        self.lockPeriod = 10.0 * 60.0;
    }

    pub fun getIERC6358Operation(addr: Address, contractName: String): &{IERC6358Operation} {
        let publicPath = PublicPath(identifier: ERC6358Protocol.IERC6358PathPrefix.concat(contractName))!;
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{IERC6358Operation}>(publicPath).borrow()!;
        return cpRef;
    }

    pub fun getSubmitterPublic(addr: Address): &{SubmitPublic} {
        let pubAcct = getAccount(addr);
        let submitterRef = pubAcct.getCapability<&{SubmitPublic}>(ERC6358Protocol.SubmitterPublicPath).borrow()!;
        return submitterRef;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // Core functions

    // signature verification without nonce update
    pub fun rawSignatureVerify(pubKey: [UInt8], rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {        
        let pk = PublicKey(publicKey: pubKey, 
                            signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

        return pk.verify(signature: signature,
                        signedData: rawData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm);
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    pub fun getPublicKey(address: Address, signatureAlgorithm: SignatureAlgorithm): PublicKey {
        let pubAcct = getAccount(address);
        let pk = PublicKey(publicKey: pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey, 
                            signatureAlgorithm: signatureAlgorithm);
        return pk;
    }

    pub fun activeOmniverse(addressOnFlow: Address) {
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        // check if `addressOnFlow` has valid `OmniverseNFT.Collection`
        // let cpRef = self.getCollectionPublic(addr: addressOnFlow);

        if !self._pk2address_map.containsKey(pkStr) {
            self._pk2address_map[pkStr] = addressOnFlow;
        }
    }

    pub fun getOmniverseIdentity(pubAddr: Address): [UInt8] {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        return pubKey.publicKey;
    }

    pub fun getFlowAddress(pubKey: [UInt8]): Address {
        let pkStr = String.encodeHex(pubKey);
        if let flowAddr = self._pk2address_map[pkStr] {
            return flowAddr;
        }

        panic("Cannot find the `pubKey` in the actived omniverse accounts!");
    }
}
