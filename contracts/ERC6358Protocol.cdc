/**
*   According to the standard at https://eips.ethereum.org/EIPS/eip-6358
*/ 

import IERC6358Token from "IERC6358Token.cdc";

pub contract ERC6358Protocol {

    pub let IERC6358PathPrefix: String

    pub let SubmitterStoragePath: StoragePath
    pub let SubmitterPublicPath: PublicPath

    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    priv let _pk2address_map: {String: Address};

    pub struct OmniverseTxData: IERC6358Token.IERC6358TxData {
        pub let txData: AnyStruct{IERC6358Token.IERC6358TxProtocol};
        pub let _time: UFix64;

        pub let hash: String;

        init(txData: AnyStruct{IERC6358Token.IERC6358TxProtocol}) {
            self.txData = txData;
            self._time = getCurrentBlock().timestamp;

            self.hash = String.encodeHex(HashAlgorithm.KECCAK_256.hash(self.txData.toBytes()));
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Omniverse operation related definations
    pub struct RecordedCertificate {
        priv var nextNonce: UInt128;
        pub let addressOnFlow: Address;
        // The index of array `PublishedTokenTx` is related nonce,
        // that is, the nonce of a `PublishedTokenTx` instance is its index in the array
        pub let publishedTx: [OmniverseTxData];
        
        pub let evil: {UInt128: [OmniverseTxData]};

        init(addressOnFlow: Address) {
            self.nextNonce = 0;
            self.addressOnFlow = addressOnFlow;
            self.publishedTx = [];
            self.evil = {};
        }

        pub fun validCheck() {
            if self.isMalicious() {
                panic("Account: ".concat(self.addressOnFlow.toString()).concat(" has been locked as malicious things!"));
            }
        }

        pub fun getWorkingNonce(): UInt128 {
            return self.nextNonce;
        }

        pub fun getTransactionCount(): UInt128 {
            return UInt128(self.publishedTx.length);
        }

        pub fun getTransactionData(nonce: UInt128): AnyStruct{IERC6358Token.IERC6358TxData} {
            if (nonce < UInt128(self.publishedTx.length)) {
                return self.publishedTx[nonce];
            }

            panic("Omniverse Transaction with nonce ".concat(nonce.toString()).concat(" does not exist!"));
        }

        // access(account) fun makeNextNonce() {
        //     self.validCheck();

        //     if self.nonce == UInt128.max {
        //         self.nonce = 0;
        //     } else {
        //         self.nonce = self.nonce + 1;
        //     }
        // }

        access(account) fun addTx(tx: OmniverseTxData) {
            self.validCheck();

            if tx.txData.nonce != UInt128(self.publishedTx.length) {
                panic("Nonce error in transaction list! Address: ".concat(self.addressOnFlow.toString()));
            }

            self.publishedTx.append(tx);
            self.nextNonce = UInt128(self.publishedTx.length);
        }

        pub fun getAllTx(): [OmniverseTxData] {
            return self.publishedTx;
        }

        pub fun getLatestTx(): OmniverseTxData? {
            let len = self.publishedTx.length;
            if len > 0 {
                return self.publishedTx[len - 1];
            } else if len == 0 {
                return nil;
            } else {
                panic("Invalid length");
            }
            return nil;
        }

        pub fun getLatestTime(): UFix64 {
            if let latestTx = self.getLatestTx() {
                return latestTx._time;
            } else {
                return 0.0;
            }
        }

        access(account) fun setMalicious(historyTx: OmniverseTxData, currentTx: OmniverseTxData) {
            if let evilRecord = (&self.evil[historyTx.txData.nonce] as &[OmniverseTxData]?) {
                evilRecord.append(currentTx);
            } else {
                self.evil[historyTx.txData.nonce] = [historyTx, currentTx];
            }
        }

        pub fun getEvils(): {UInt128: [OmniverseTxData]}{
            return self.evil;
        }

        pub fun isMalicious(): Bool {
            return self.evil.length > 0;
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////

    pub resource interface SubmitPublic {
        pub fun getSubmittedTx(): AnyStruct{IERC6358Token.IERC6358TxProtocol};
    }

    pub resource TxSubmitter: SubmitPublic {
        priv var sTxData: AnyStruct{IERC6358Token.IERC6358TxProtocol}?;

        init() {
            self.sTxData = nil;
        }

        pub fun setSubmittedTx(sTxData: AnyStruct{IERC6358Token.IERC6358TxProtocol}) {
            self.sTxData = sTxData;
        }

        pub fun clearSubmittedTx() {
            self.sTxData = nil;
        }

        pub fun getSubmittedTx(): AnyStruct{IERC6358Token.IERC6358TxProtocol} {
            return self.sTxData!;
        }
    }

    init() {
        self._pk2address_map = {};

        self.IERC6358PathPrefix = "IERC6358";

        self.SubmitterStoragePath = /storage/SubmitterPath;
        self.SubmitterPublicPath = /public/SubmitterPath;
    }

    pub fun getIERC6358Operation(addr: Address, contractName: String): &{IERC6358Token.IERC6358Operation} {
        let publicPath = PublicPath(identifier: ERC6358Protocol.IERC6358PathPrefix.concat(contractName))!;
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{IERC6358Token.IERC6358Operation}>(publicPath).borrow()!;
        return cpRef;
    }

    pub fun getSubmitterPublic(addr: Address): &{SubmitPublic} {
        let pubAcct = getAccount(addr);
        let submitterRef = pubAcct.getCapability<&{SubmitPublic}>(ERC6358Protocol.SubmitterPublicPath).borrow()!;
        return submitterRef;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // Core functions

    // signature verification without nonce update
    pub fun rawSignatureVerify(pubKey: [UInt8], rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {        
        let pk = PublicKey(publicKey: pubKey, 
                            signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

        return pk.verify(signature: signature,
                        signedData: rawData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm);
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    pub fun getPublicKey(address: Address, signatureAlgorithm: SignatureAlgorithm): PublicKey {
        let pubAcct = getAccount(address);
        let pk = PublicKey(publicKey: pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey, 
                            signatureAlgorithm: signatureAlgorithm);
        return pk;
    }

    pub fun activeOmniverse(addressOnFlow: Address) {
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        // check if `addressOnFlow` has valid `OmniverseNFT.Collection`
        // let cpRef = self.getCollectionPublic(addr: addressOnFlow);

        if !self._pk2address_map.containsKey(pkStr) {
            self._pk2address_map[pkStr] = addressOnFlow;
        }
    }

    pub fun getOmniverseIdentity(pubAddr: Address): [UInt8] {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        return pubKey.publicKey;
    }

    pub fun getFlowAddress(pubKey: [UInt8]): Address {
        let pkStr = String.encodeHex(pubKey);
        if let flowAddr = self._pk2address_map[pkStr] {
            return flowAddr;
        }

        panic("Cannot find the `pubKey` in the actived omniverse accounts!");
    }
}
