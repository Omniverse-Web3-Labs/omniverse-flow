/* 
*
*   This is an omniverse NFT Guader
*   With this infrastructure, any NFT contracts and resources under Flow's NFT standard, 
*   that is, has implemented `NonFungibleToken.INFT` and `MetadataViews.Resolver`, 
*   could be omniverse. 
*   'Omniverse' means that features of an NFT on Flow can be synchronous on every other chains, 
*   including the ownership transferring.
*
*   Note that NFTs on Flow are special, 
*   which means that NFTs on Flow have more features(such as dynamic and executable features) than on other chains,
*   so `OmniverseNFT` can not support NFTs minted on other chains first and sychronized to Flow.
*
*   We also provide an `OmniverseFT` protocol for Fungible Tokens. In fact, the `OmniverseFT` protocol does also support Flow to become an omniverse token,
*   which could be only operated on other chains anchoring the Flow-token originally published on Flow chain but not be made out of nothing.
*   
*/

import NonFungibleToken from "./NonFungibleToken.cdc"
import MetadataViews from "./MetadataViews.cdc"

pub contract OmniverseNFT: NonFungibleToken {

    pub let domainName: String
    pub var totalSupply: UInt64

    // especial for Omniverse
    // priv var nonce: {String: UInt128};

    // record omniverse public keys and their address
    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    // priv var omniIdentityRecorder: {String: Address};

    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    priv let publishedRecorder: {String: RecordedCertificate};

    // Store pending NFTs
    priv let NFTShelter: @{String: [OmniverseNFT.NFT]};

    // Store NFTs ready to out, this is the only place to change `OmniverseNFT.NFT` to source `NonFungibleToken.NFT` on Flow
    priv let StarPort: @{String: [OmniverseNFT.NFT]};

    // Store punishment NFTs
    priv let Prisons: @{String: [OmniverseNFT.NFT]};

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    pub let lockPeriod: UFix64;

    pub struct OmniverseNFTProtocol {
        pub let nonce: UInt128;
        // resource uuid, which is the unique id for resources on Flow
        pub let omniID: UInt64;
        // IPFS URI
        pub let tokenURI: String;
        // Flow is special, 
        // and remember to put the omniverse address in the position of first public key as the Omniverse address
        // Note that `SignatureAlgorithm.ECDSA_secp256k1` is neccessary
        pub let sender: [UInt8]?;
        pub let recver: [UInt8]?;
        // 0: deposit
        // 1: transfer
        // 2: withdraw
        pub let operation: UInt8;

        init(nonce: UInt128, id: UInt64, tokenURI: String, sender: [UInt8]?, recver: [UInt8]?, operation: UInt8) {
            self.nonce = nonce;
            self.omniID = id;
            self.tokenURI = tokenURI;
            self.sender = sender;
            self.recver = recver;
            self.operation = operation;
        }

        pub fun toBytesExceptNonce(): [UInt8] {
            var output: [UInt8] = [];
            
            output = output.concat(self.omniID.toBigEndianBytes());
            output = output.concat(self.tokenURI.utf8);

            if let sender = self.sender {
                output = output.concat(sender);
            }
            if let recver = self.recver {
                output = output.concat(recver);
            }

            output.append(self.operation);
            
            return output;
        }

        pub fun getOperateIdentity(): [UInt8] {
            switch self.operation {
                case UInt8(0):
                    return self.recver!;
                case UInt8(1):
                    return self.sender!;
                case UInt8(2):
                    return self.sender!;
            }

            panic("Invalid operation! Got: ".concat(self.operation.toString()));
        }
    }

    pub struct PublishedTx {
        pub let oNFTProtocol: OmniverseNFTProtocol;
        pub let signature: [UInt8];
        pub let timestamp: UFix64;

        init(oNFTProtocol: OmniverseNFTProtocol, signature: [UInt8]) {
            self.oNFTProtocol = oNFTProtocol;
            self.signature = signature;
            self.timestamp = getCurrentBlock().timestamp;
        }
    }

    pub struct RecordedCertificate {
        priv var nonce: UInt128;
        pub let addressOnFlow: Address;
        pub let publishedTx: [PublishedTx];
        pub let evil: {UInt128: [PublishedTx]};

        init(addressOnFlow: Address) {
            self.nonce = 0;
            self.addressOnFlow = addressOnFlow;
            self.publishedTx = [];
            self.evil = {};
        }

        pub fun validCheck() {
            if self.isMalicious() {
                panic("Account: ".concat(self.addressOnFlow.toString()).concat(" has been locked as malicious things!"));
            }
        }

        pub fun getWorkingNonce(): UInt128 {
            return self.nonce + 1;
        }

        access(contract) fun makeNextNonce() {
            self.validCheck();

            if self.nonce == UInt128.max {
                self.nonce = 0;
            } else {
                self.nonce = self.nonce + 1;
            }
        }

        access(contract) fun addTx(tx: PublishedTx) {
            self.validCheck();

            self.publishedTx.append(tx);
            if UInt128(self.publishedTx.length - 1) != tx.oNFTProtocol.nonce {
                // assert index is equal to nonce
                panic("Nonce error in transaction list! Address: ".concat(self.addressOnFlow.toString()));
            }
        }

        pub fun getAllTx(): [PublishedTx] {
            return self.publishedTx;
        }

        pub fun getLatestTx(): PublishedTx? {
            let len = self.publishedTx.length;
            if len > 0 {
                return self.publishedTx[len - 1];
            } else if len == 0 {
                return nil;
            } else {
                panic("Invalid length");
            }
            return nil;
        }

        pub fun getLatestTime(): UFix64 {
            if let latestTx = self.getLatestTx() {
                return latestTx.timestamp;
            } else {
                return 0.0;
            }
        }

        access(contract) fun setMalicious(historyTx: PublishedTx, currentTx: PublishedTx) {
            if let evilRecord = (&self.evil[historyTx.oNFTProtocol.nonce] as &[PublishedTx]?) {
                evilRecord.append(currentTx);
            } else {
                self.evil[historyTx.oNFTProtocol.nonce] = [historyTx, currentTx];
            }
        }

        pub fun getEvils(): {UInt128: [PublishedTx]}{
            return self.evil;
        }

        pub fun isMalicious(): Bool {
            return self.evil.length > 0;
        }
    }

    // An omniverse NFT wrapper for all `NonFungibleToken.INFT` resource on Flow
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // this `id` is the uuid of an NFT resource
        pub let id: UInt64;
        priv var lockedTime: UFix64;
        priv var iNFT: @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver}?;
    
        init(iNFT: @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver}) {
            self.id = iNFT.uuid;
            self.iNFT <- iNFT;
            self.lockedTime = 0.0;
        }

        pub destroy() {
            destroy self.iNFT;
        }
    
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            let nftRef = (&self.iNFT as! auth &AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver}?)!;
            return nftRef.resolveView(view);
        }

        pub fun borrow(): &NonFungibleToken.NFT {
            let nftRef = (&self.iNFT as! auth &AnyResource{NonFungibleToken.INFT}?)!;
            return nftRef as! &NonFungibleToken.NFT;
        }

        access(contract) fun setLockedTime() {
            self.lockedTime = getCurrentBlock().timestamp;
        }

        pub fun getLockedTime(): UFix64 {
            return self.lockedTime;
        }

        access(contract) fun extract(): @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver} {
            let out <- self.iNFT <- nil;
            //self.iNFT <-! nil;
            return <- out!;
        }
    }

    pub resource interface OmniverseNFTCollectionPublic {
        pub fun omniverseTransfer(omniverse: OmniverseNFTProtocol, signature: [UInt8]);
        access(contract) fun omniverseReceive(omniNFT: @NonFungibleToken.NFT);

        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowOmniverseNFT(id: UInt64): &OmniverseNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow ExampleNFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: OmniverseNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        access(contract) init () {
            self.ownedNFTs <- {}
        }

        // @param nft: Any `NonFungibleToken.NFT` on Flow
        pub fun omniverseDeposit(nft: @NonFungibleToken.NFT, 
                                omniverse: OmniverseNFTProtocol, 
                                signature: [UInt8]) {
            // check if operation identity in `OmniverseNFTProtocol` is the same as `Collection.owner`
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            let pk = OmniverseNFT.getPublicKey(address: opAddressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

            if omniverse.operation != 0 {
                panic("Invalid operation. Need `0` for `deposit`. Got: ".concat(omniverse.operation.toString()))
            }

            let omniOpIdentity = omniverse.getOperateIdentity();
            if String.encodeHex(omniOpIdentity) != String.encodeHex(pk.publicKey) {
                panic("Operation identities are mismatched!");
            }
            //////////////////////////////////////////////////////////////////////////
            let publishedTx = PublishedTx(oNFTProtocol: omniverse, signature: signature);

            // check uuid. 
            if nft.uuid != omniverse.omniID {
                panic("Invalid `omniverse.omniID`");
            }

            // check input nonce
            let workingNonce = OmniverseNFT.getWorkingNonce(pubAddr: opAddressOnFlow);
            if workingNonce == omniverse.nonce {
                // check signature
                if (OmniverseNFT.omniverseVerify(pubAddr: opAddressOnFlow, 
                                                    rawData: omniverse.toBytesExceptNonce(), 
                                                    signature: signature, 
                                                    hashAlgorithm: HashAlgorithm.KECCAK_256)) {
                    
                    // check locked time
                    let currentTime = getCurrentBlock().timestamp;
                    if (currentTime - OmniverseNFT.getLatestTxTime(pubKey: pk.publicKey)) < OmniverseNFT.lockPeriod {
                        panic("Transaction locking has not cooled down!")
                    }

                    // do the creation of a new omniverse NFT
                    let nft_i <- nft as! @AnyResource{NonFungibleToken.INFT};
                    let rawNFT <- nft_i as! @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver};
                    let omniverseNFT <- create OmniverseNFT.NFT(iNFT: <- rawNFT);

                    //let oldToken <- self.ownedNFTs[omniverse.omniID] <- omniverseNFT;
                    // emit Deposit(id: id, to: self.owner?.address)
                    //destroy oldToken;
                    omniverseNFT.setLockedTime();
                    OmniverseNFT.addPendingNFT(recvIdentity: omniverse.recver!, nft: <- omniverseNFT);

                    // update omniverse state
                    OmniverseNFT.addPublishedTx(pubAddr:opAddressOnFlow, publishedTx: publishedTx);

                } else {
                    panic("Omniverse signature verification failed!");
                }
            } /* 
            // Actually, we should not get in this branch as deposite will only happen on Flow
            else if workingNonce > omniverse.nonce {
                // This is a history transaction and check conflicts
                OmniverseNFT.checkConflict(tx: publishedTx);
            }*/ 
            else {
                panic("Mismatched input nonce and working nonce!");
            }
        }

        pub fun omniverseWithdraw(omniverse: OmniverseNFTProtocol, 
                                signature: [UInt8]) {
            // check if operation identity in `OmniverseNFTProtocol` is the same as `Collection.owner`
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            let pk = OmniverseNFT.getPublicKey(address: opAddressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
            
            if omniverse.operation != 2 {
                panic("Invalid operation. Need `2` for `withdraw`. Got: ".concat(omniverse.operation.toString()))
            }

            let omniOpIdentity = omniverse.getOperateIdentity();
            if String.encodeHex(omniOpIdentity) != String.encodeHex(pk.publicKey) {
                panic("Operation identities are mismatched!");
            }
            //////////////////////////////////////////////////////////////////////////
            let publishedTx = PublishedTx(oNFTProtocol: omniverse, signature: signature);
            // check input nonce
            let workingNonce = OmniverseNFT.getWorkingNonce(pubAddr: opAddressOnFlow);
            if workingNonce == omniverse.nonce {
                if (!OmniverseNFT.omniverseVerify(pubAddr: opAddressOnFlow, 
                                                rawData: omniverse.toBytesExceptNonce(), 
                                                signature: signature, 
                                                hashAlgorithm: HashAlgorithm.KECCAK_256)) {
                    panic("Invalid signature!");                                          
                }

                // check locked time
                let currentTime = getCurrentBlock().timestamp;
                if (currentTime - OmniverseNFT.getLatestTxTime(pubKey: pk.publicKey)) < OmniverseNFT.lockPeriod {
                    panic("Transaction locking has not cooled down!")
                }

                // get the OmniverseNFT out
                let token <- self.ownedNFTs.remove(key: omniverse.omniID) ?? panic("missing NFT")
                let omniverseToken <- (token as! @OmniverseNFT.NFT);
                omniverseToken.setLockedTime();
                OmniverseNFT.addExtractNFT(recvIdentity: omniverse.recver!, nft: <- omniverseToken);

                // update omniverse state
                OmniverseNFT.addPublishedTx(pubAddr:opAddressOnFlow, publishedTx: publishedTx);
            } else if workingNonce > omniverse.nonce {
                // This is a history transaction and check conflicts
                OmniverseNFT.checkConflict(tx: publishedTx);
            } else {
                panic("Mismatched input nonce and working nonce!");
            }
        }

        pub fun omniverseTransfer(omniverse: OmniverseNFTProtocol, signature: [UInt8]) {
            // check if operation identity in `OmniverseNFTProtocol` is the same as `Collection.owner`
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            let pk = OmniverseNFT.getPublicKey(address: opAddressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

            if omniverse.operation != 1 {
                panic("Invalid operation. Need `1` for `transfer`. Got: ".concat(omniverse.operation.toString()))
            }

            let omniOpIdentity = omniverse.getOperateIdentity();
            if String.encodeHex(omniOpIdentity) != String.encodeHex(pk.publicKey) {
                panic("Operation identities are mismatched!");
            }
            //////////////////////////////////////////////////////////////////////////
            let publishedTx = PublishedTx(oNFTProtocol: omniverse, signature: signature);

            if omniverse.recver == nil {
                panic("Invalid recver identity");
            }

            let workingNonce = OmniverseNFT.getWorkingNonce(pubAddr: opAddressOnFlow);
            if workingNonce == omniverse.nonce {
                if (!OmniverseNFT.omniverseVerify(pubAddr: opAddressOnFlow, 
                                                rawData: omniverse.toBytesExceptNonce(), 
                                                signature: signature, 
                                                hashAlgorithm: HashAlgorithm.KECCAK_256)) {
                    panic("Invalid signature!");                                          
                }

                //////////////////////////////////////////////////////////
                // TODO: reward off-chain nodes
                //////////////////////////////////////////////////////////

                // check locked time
                let currentTime = getCurrentBlock().timestamp;
                if (currentTime - OmniverseNFT.getLatestTxTime(pubKey: pk.publicKey)) < OmniverseNFT.lockPeriod {
                    panic("Transaction locking has not cooled down!")
                }

                // get the OmniverseNFT out
                let token <- self.ownedNFTs.remove(key: omniverse.omniID) ?? panic("missing NFT");

                // get receiver collection
                /*
                if let recvAddressOnFlow = OmniverseNFT.getFlowAddress(pubKey: omniverse.recver!) {
                    let recvClctRef = OmniverseNFT.getOmniversePublic(addr: recvAddressOnFlow);
                    recvClctRef.omniverseReceive(omniNFT: <- token);
                } else {
                    OmniverseNFT.addPendingNFT(recvIdentity: omniverse.recver!, nft: <- (token as! @OmniverseNFT.NFT));
                }
                */
                let omniverseToken <- (token as! @OmniverseNFT.NFT);
                omniverseToken.setLockedTime();
                OmniverseNFT.addPendingNFT(recvIdentity: omniverse.recver!, nft: <- omniverseToken);

                // update omniverse state
                OmniverseNFT.addPublishedTx(pubAddr:opAddressOnFlow, publishedTx: publishedTx);
            } else if workingNonce > omniverse.nonce {
                // This is a history transaction and check conflicts
                OmniverseNFT.checkConflict(tx: publishedTx);
            } else {
                panic("Mismatched input nonce and working nonce!");
            }
        }

        access(contract) fun omniverseReceive(omniNFT: @NonFungibleToken.NFT) {
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            let token <- omniNFT as! @OmniverseNFT.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            // emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            // TODO: Omniverse SYNC

            panic("`withdraw` is deprecated in OmniverseNFT");

            // let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
            // return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            panic("`deposit` is deprecated in OmniverseNFT");

            //let token <- token as! @OmniverseNFT.NFT
            //let id: UInt64 = token.id
            //let oldToken <- self.ownedNFTs[id] <- token
            // emit Deposit(id: id, to: self.owner?.address)
            //destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }
 
        pub fun borrowOmniverseNFT(id: UInt64): &OmniverseNFT.NFT? {
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &OmniverseNFT.NFT
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let opAddressOnFlow = self.owner!.address;
            OmniverseNFT.checkValid(opAddressOnFlow: opAddressOnFlow);

            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let exampleNFT = nft as! &OmniverseNFT.NFT
            return exampleNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    init() {

        self.domainName = "Omniverse NFT"
        // Initialize the total supply
        self.totalSupply = 0

        self.publishedRecorder = {};
        self.NFTShelter <- {};
        self.StarPort <- {};
        self.Prisons <- {};

        // Set the named paths
        self.CollectionStoragePath = /storage/omniverseNFTCollection
        self.CollectionPublicPath = /public/omniverseNFTCollection

        self.lockPeriod = 10.0 * 60.0;
    }

    pub fun activeOmniverse(addressOnFlow: Address) {
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        // check if `addressOnFlow` has valid `OmniverseNFT.Collection`
        let cpRef = self.getCollectionPublic(addr: addressOnFlow);

        if !self.publishedRecorder.containsKey(pkStr) {
            self.publishedRecorder[pkStr] = OmniverseNFT.RecordedCertificate(addressOnFlow: addressOnFlow);
        }
    }

    pub fun claimOmniverseNFTs(addressOnFlow: Address) {
        self.checkValid(opAddressOnFlow: addressOnFlow);

        // do claim job
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);
        // check if `addressOnFlow` has valid `OmniverseNFT.Collection`
        let cpRef = self.getOmniversePublic(addr: addressOnFlow);
        // active `addressOnFlow` first
        if !self.publishedRecorder.containsKey(pkStr) {
            self.publishedRecorder[pkStr] = OmniverseNFT.RecordedCertificate(addressOnFlow: addressOnFlow);
        }
        // claim all pended NFTs under public key `pkStr`
        if let shelter = (&self.NFTShelter[pkStr] as &[OmniverseNFT.NFT]?) {
            var counts = shelter.length;
            while counts > 0 {
                let idx = shelter.length - 1;
                if (getCurrentBlock().timestamp - shelter[idx].getLockedTime()) > self.lockPeriod {
                    let pendedNFT <- shelter.remove(at: idx);
                    cpRef.omniverseReceive(omniNFT: <- pendedNFT);
                }

                counts = counts - 1;
            }
        }
    }

    pub fun extractFromStarPort(addressOnFlow: Address): @[NonFungibleToken.NFT] {
        self.checkValid(opAddressOnFlow: addressOnFlow);
        let out: @[NonFungibleToken.NFT] <- [];
        
        let pk = self.getPublicKey(address: addressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        if let starPort = (&self.StarPort[pkStr] as &[OmniverseNFT.NFT]?) {
            var counts = starPort.length;
            while counts > 0 {
                let idx = starPort.length - 1;
                if (getCurrentBlock().timestamp - starPort[idx].getLockedTime()) > self.lockPeriod {
                    let pendedNFT <- starPort.remove(at: idx);
                    let srcNft <- pendedNFT.extract();
                    let outNFT <- srcNft as! @{NonFungibleToken.INFT};
                    out.append(<- (outNFT as! @NonFungibleToken.NFT));
                    destroy pendedNFT;
                }

                counts = counts - 1;
            }
        }

        return <- out;
    }

    pub fun getCollectionPublic(addr: Address): &{NonFungibleToken.CollectionPublic} {
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{NonFungibleToken.CollectionPublic}>(self.CollectionPublicPath).borrow()!;
        return cpRef;
    }

    pub fun getOmniversePublic(addr: Address): &{OmniverseNFTCollectionPublic} {
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{OmniverseNFTCollectionPublic}>(self.CollectionPublicPath).borrow()!;
        return cpRef;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // for signature verification
    pub fun getPublicKey(address: Address, signatureAlgorithm: SignatureAlgorithm): PublicKey {
        let pubAcct = getAccount(address);
        let pk = PublicKey(publicKey: pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey, 
                            signatureAlgorithm: signatureAlgorithm);
        return pk;
    }

    access(contract) fun addPublishedTx(pubAddr: Address, publishedTx: PublishedTx) {
        let pkStr = String.encodeHex(publishedTx.oNFTProtocol.getOperateIdentity());
        if let rc = (&self.publishedRecorder[pkStr] as &RecordedCertificate?) {
            rc.addTx(tx: publishedTx);            
        } else {
            let rc = RecordedCertificate(addressOnFlow: pubAddr);
            rc.addTx(tx: publishedTx); 
            self.publishedRecorder[pkStr] = rc;
        }
    }

    access(contract) fun addPendingNFT(recvIdentity: [UInt8], nft: @OmniverseNFT.NFT) {
        let recvStr = String.encodeHex(recvIdentity);
        if let shelter = (&self.NFTShelter[recvStr] as &[OmniverseNFT.NFT]?) {
            shelter.append(<- nft);
        } else {
            self.NFTShelter[recvStr] <-! [<-nft];
        }
    }

    access(contract) fun addExtractNFT(recvIdentity: [UInt8], nft: @OmniverseNFT.NFT) {
        let recvStr = String.encodeHex(recvIdentity);
        if let starPort = (&self.StarPort[recvStr] as &[OmniverseNFT.NFT]?) {
            starPort.append(<- nft);
        } else {
            self.StarPort[recvStr] <-! [<-nft];
        }
    }

    priv fun takeout(id: UInt64, container: &[OmniverseNFT.NFT]): @OmniverseNFT.NFT? {
        let count = container.length;
        var idx = 0;
        while idx < count {
            if container[idx].id == id {
                return <- container.remove(at: idx);
            }
            
            idx = idx + 1;
        }

        return nil;
    }

    priv fun lockedUpInPrison(tx: PublishedTx) {
        let recverStr = String.encodeHex(tx.oNFTProtocol.recver!);
        let opStr = String.encodeHex(tx.oNFTProtocol.getOperateIdentity());

        if tx.oNFTProtocol.operation == 2 {
            // history operation is `withdraw`, so NFT is in `StarPort`
            if let container = (&self.StarPort[recverStr] as &[OmniverseNFT.NFT]?) {
                if let nft <- self.takeout(id: tx.oNFTProtocol.omniID, container: container) {
                    if let prisons = (&self.Prisons[opStr] as &[OmniverseNFT.NFT]?) {
                        prisons.append(<- nft);
                    } else {
                        self.Prisons[opStr] <-! [<- nft];
                    }
                }
            }
        } else if tx.oNFTProtocol.operation == 1 {
            // history operation is `transfer`, so NFT is in `NFTShelter`
            if let container = (&self.NFTShelter[recverStr] as &[OmniverseNFT.NFT]?) {
                if let nft <- self.takeout(id: tx.oNFTProtocol.omniID, container: container) {
                    if let prisons = (&self.Prisons[opStr] as &[OmniverseNFT.NFT]?) {
                        prisons.append(<- nft);
                    } else {
                        self.Prisons[opStr] <-! [<- nft];
                    }
                }
            }
        }
    }
    
    // If there's no conflicts, returns true
    access(contract) fun checkConflict(tx: PublishedTx): Bool {
        let rawData = tx.oNFTProtocol.nonce.toBigEndianBytes().concat(tx.oNFTProtocol.toBytesExceptNonce());
        let opIdentity = tx.oNFTProtocol.getOperateIdentity();
        if !OmniverseNFT.rawVerify(pubKey: opIdentity, 
                                    rawData: rawData, 
                                    signature: tx.signature, 
                                    hashAlgorithm: HashAlgorithm.KECCAK_256) {
            panic("Unauthority Data!");
        }

        //////////////////////////////////////////////////////////
        // TODO: reward off-chain nodes
        //////////////////////////////////////////////////////////

        let opStr = String.encodeHex(opIdentity);
        if let rc = (&self.publishedRecorder[opStr] as &OmniverseNFT.RecordedCertificate?) {
            let historyTx = rc.publishedTx[tx.oNFTProtocol.nonce];
            if historyTx.oNFTProtocol.nonce != tx.oNFTProtocol.nonce {
                panic("Nonce-index mechanism failed!");
            }

            if String.encodeHex(historyTx.oNFTProtocol.toBytesExceptNonce()) != String.encodeHex(tx.oNFTProtocol.toBytesExceptNonce()) {
                rc.setMalicious(historyTx: historyTx, currentTx: tx);
                // take the NFT into prisons
                let recverIdentity = historyTx.oNFTProtocol.recver!;
                self.lockedUpInPrison(tx: historyTx);
                return false;
            } else {
                return true;
            }
        }

        panic("Nonce mechanism crushed at identity: ".concat(opStr));
    }

    // Verify whether both the `pubAddr` and `rawData` are valid
    // `pubAddr` is the address of the message submitter, e.g. the off-chain router
    // So the `signature` is composited with: `pubAddr` + `self.nonce` + `rawData`
    access(contract) fun omniverseVerify(pubAddr: Address, rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pubKey.publicKey);
        
        var nonceV: UInt128 = 0;
        if let rc = self.publishedRecorder[pkStr] {
            nonceV = rc.getWorkingNonce();
        }
        
        let originData: [UInt8] = nonceV.toBigEndianBytes().concat(rawData);
        //log(String.encodeHex(rawData));
        //log(String.encodeHex(originData));
        //log(pubAddr);
        //log(String.encodeHex(pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey));
        //log(String.encodeHex(signature));

        if (pubKey.verify(signature: signature,
                        signedData: originData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm)) {
            
            if let rc = (&self.publishedRecorder[pkStr] as &RecordedCertificate?) {
                rc.makeNextNonce();
            } else {
                let rc = RecordedCertificate(addressOnFlow: pubAddr);
                self.publishedRecorder[pkStr] = rc;
            }

            return true;
        } else {
            return false;
        }
    }

    // signature verification without nonce update
    pub fun rawVerify(pubKey: [UInt8], rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {        
        let pk = PublicKey(publicKey: pubKey, 
                            signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);

        return pk.verify(signature: signature,
                        signedData: rawData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm);
    }

    pub fun checkValid(opAddressOnFlow: Address): Bool {
        let pk = OmniverseNFT.getPublicKey(address: opAddressOnFlow, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pk.publicKey);

        if let rc = (&self.publishedRecorder[pkStr] as &RecordedCertificate?) {
            if rc.isMalicious() {
                panic("The address did malicious things and has been locked now!");
            }
        }

        return true;
    }

    pub fun getOmniverseIdentity(pubAddr: Address): [UInt8] {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        return pubKey.publicKey;
    }

    pub fun getFlowAddress(pubKey: [UInt8]): Address? {
        let pkStr = String.encodeHex(pubKey);
        if let rc = self.publishedRecorder[pkStr] {
            return rc.addressOnFlow;
        }

        return nil;
    }

    pub fun getWorkingNonce(pubAddr: Address): UInt128 {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pubKey.publicKey);
        if let rc = self.publishedRecorder[pkStr] {
            return rc.getWorkingNonce();
        } else {
            return 0;
        }
    }

    pub fun getLatestTxTime(pubKey: [UInt8]): UFix64 {
        let pkStr = String.encodeHex(pubKey);
        if let rc = self.publishedRecorder[pkStr] {
            return rc.getLatestTime();
        }

        return 0.0;
    }
}
 