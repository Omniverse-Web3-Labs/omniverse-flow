/* 
*
*   This is an omniverse NFT Guader
*   With this infrastructure, any NFT contracts and resources under Flow's NFT standard, 
*   that is, has implemented `NonFungibleToken.INFT` and `MetadataViews.Resolver`, 
*   could be omniverse. 
*   'Omniverse' means that features of an NFT on Flow can be synchronous on every other chains, 
*   including the ownership transferring.
*
*   Note that NFTs on Flow are special, 
*   which means that NFTs on Flow have more features(such as dynamic and executable features) than on other chains,
*   so `OmniverseNFT` can not support NFTs minted on other chains first and sychronized to Flow.
*
*   We also provide an `OmniverseFT` protocol for Fungible Tokens. In fact, the `OmniverseFT` protocol does also support Flow to become an omniverse token,
*   which could be only operated on other chains anchoring the Flow-token originally published on Flow chain but not be made out of nothing.
*   
*/

import NonFungibleToken from "./NonFungibleToken.cdc"
import MetadataViews from "./MetadataViews.cdc"

pub contract OmniverseNFT: NonFungibleToken {

    pub let domainName: String
    pub var totalSupply: UInt64

    // especial for Omniverse
    // priv var nonce: {String: UInt128};

    // record omniverse public keys and their address
    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    // priv var omniIdentityRecorder: {String: Address};

    // key is generated by `String.encodeHex(publicKey: [UInt8])`
    priv let publishedRecorder: {String: RecordedCertificate};

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    pub struct OmniverseNFTProtocol {
        // resource uuid, which is the unique id for resources on Flow
        pub let uuid: UInt64;
        // Flow is special, 
        // and remember to put the omniverse address in the position of first public key as the Omniverse address
        // Note that `SignatureAlgorithm.ECDSA_secp256k1` is neccessary
        pub let sender: Address?;
        pub let recver: Address?;
        // 0: deposit
        // 1: transfer
        // 2: withdraw
        pub let operation: UInt8;

        init(uuid: UInt64, sender: Address?, recver: Address?, operation: UInt8) {
            self.uuid = uuid;
            self.sender = sender;
            self.recver = recver;
            self.operation = operation;
        }

        pub fun toBytes(): [UInt8] {
            var output: [UInt8] = [];
            
            output = output.concat(self.uuid.toBigEndianBytes());

            if let sender = self.sender {
                output = output.concat(OmniverseNFT.getPublicKey(address: sender, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1).publicKey);
            }
            if let recver = self.recver {
                output = output.concat(OmniverseNFT.getPublicKey(address: recver, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1).publicKey);
            }

            output.append(self.operation);
            
            return output;
        }

        pub fun getOperateAddress(): Address {
            switch self.operation {
                case UInt8(0):
                    return self.recver!;
                case UInt8(1):
                    return self.sender!;
                case UInt8(2):
                    return self.sender!;
            }

            panic("Invalid operation! Got: ".concat(self.operation.toString()));
        }
    }

    pub struct PublishedTx {
        pub let oNFTProtocol: OmniverseNFTProtocol;
        pub let signature: [UInt8];
        pub let timestamp: UFix64;

        init(oNFTProtocol: OmniverseNFTProtocol, signature: [UInt8]) {
            self.oNFTProtocol = oNFTProtocol;
            self.signature = signature;
            self.timestamp = getCurrentBlock().timestamp;
        }
    }

    pub struct RecordedCertificate {
        priv var nonce: UInt128;
        pub let addressOnFlow: Address;
        pub let publishedTx: [PublishedTx];

        init(addressOnFlow: Address) {
            self.nonce = 0;
            self.addressOnFlow = addressOnFlow;
            self.publishedTx = [];
        }

        pub fun getWorkingNonce(): UInt128 {
            return self.nonce + 1;
        }

        access(contract) fun makeNextNonce() {
            if self.nonce == UInt128.max {
                self.nonce = 0;
            } else {
                self.nonce = self.nonce + 1;
            }
        }

        access(contract) fun addTx(tx: PublishedTx) {
            self.publishedTx.append(tx);
        }

        pub fun getAllTx(): [PublishedTx] {
            return self.publishedTx;
        }

        pub fun getLatestTx(): PublishedTx? {
            let len = self.publishedTx.length;
            if len > 0 {
                return self.publishedTx[len - 1];
            } else if len == 0 {
                return nil;
            } else {
                panic("Invalid length");
            }
            return nil;
        }

        pub fun getLatestTime(): UFix64 {
            if let latestTx = self.getLatestTx() {
                return latestTx.timestamp;
            } else {
                return 0.0;
            }
        }
    }

    // An omniverse NFT wrapper for all `NonFungibleToken.INFT` resource on Flow
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // this `id` is the uuid of an NFT resource
        pub let id: UInt64;

        priv var iNFT: @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver};
    
        init(
            uuid: UInt64, iNFT: @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver}
        ) {
            self.id = uuid;
            self.iNFT <- iNFT;
        }

        pub destroy() {
            destroy self.iNFT;
        }
    
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            return self.iNFT.resolveView(view);
        }

        pub fun borrow(): &NonFungibleToken.NFT {
            let nftRef = (&self.iNFT as? auth &AnyResource{NonFungibleToken.INFT})!;
            return nftRef as! &NonFungibleToken.NFT;
        }
    }

    pub resource interface OmniverseNFTCollectionPublic {
        pub fun omniverseTransfer(omniverse: OmniverseNFTProtocol, signature: [UInt8]);
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowOmniverseNFT(id: UInt64): &OmniverseNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow ExampleNFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: OmniverseNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        access(contract) init () {
            self.ownedNFTs <- {}
        }

        // This protocol only 
        pub fun omniverseDeposit(nft: @NonFungibleToken.NFT, 
                                omniverse: OmniverseNFTProtocol, 
                                signature: [UInt8]) {
            if omniverse.operation != 0 {
                panic("Omniverse deposit needs operation 0, got: ".concat(omniverse.operation.toString()));
            }

            if omniverse.recver == nil {
                panic("`recver` loss");
            }

            if nft.uuid != omniverse.uuid {
                panic("Invalid `omniverse.uuid`");
            }

            if (!OmniverseNFT.omniverseVerify(pubAddr: omniverse.getOperateAddress(), 
                                                rawData: omniverse.toBytes(), 
                                                signature: signature, 
                                                hashAlgorithm: HashAlgorithm.KECCAK_256)) {
                panic("Invalid signature!");                                          
            }

            let nft_i <- nft as! @AnyResource{NonFungibleToken.INFT};
            let rawNFT <- nft_i as! @AnyResource{NonFungibleToken.INFT, MetadataViews.Resolver};
            let omniverseNFT <- create OmniverseNFT.NFT(uuid: omniverse.uuid, iNFT: <- rawNFT);

            let oldToken <- self.ownedNFTs[omniverse.uuid] <- omniverseNFT;
            // emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken;

            // update omniverse state
            let publishedTx = PublishedTx(oNFTProtocol: omniverse, signature: signature);
            let pk = OmniverseNFT.getPublicKey(address: omniverse.recver!, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
            OmniverseNFT.addPublishedTx(pubKey: pk.publicKey, publishedTx: publishedTx);
        }

        pub fun omniverseWithdraw() {
        
        }

        pub fun omniverseTransfer(omniverse: OmniverseNFTProtocol, signature: [UInt8]) {
        
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            // TODO: Omniverse SYNC

            panic("`withdraw` is deprecated in OmniverseNFT");

            // let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
            // return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            panic("`deposit` is deprecated in OmniverseNFT");

            //let token <- token as! @OmniverseNFT.NFT
            //let id: UInt64 = token.id
            //let oldToken <- self.ownedNFTs[id] <- token
            // emit Deposit(id: id, to: self.owner?.address)
            //destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }
 
        pub fun borrowOmniverseNFT(id: UInt64): &OmniverseNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &OmniverseNFT.NFT
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let exampleNFT = nft as! &OmniverseNFT.NFT
            return exampleNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    init() {

        self.domainName = "Omniverse NFT"
        // Initialize the total supply
        self.totalSupply = 0

        self.publishedRecorder = {};

        // Set the named paths
        self.CollectionStoragePath = /storage/omniverseNFTCollection
        self.CollectionPublicPath = /public/omniverseNFTCollection

        // Create a Collection resource and save it to storage
        //let collection <- create Collection()
        //self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        //self.account.link<&OmniverseNFT.Collection{NonFungibleToken.CollectionPublic, OmniverseNFT.OmniverseNFTCollectionPublic, MetadataViews.ResolverCollection}>(
        //    self.CollectionPublicPath,
        //    target: self.CollectionStoragePath
        //)
    }

    pub fun getCollectionPublic(addr: Address): &{NonFungibleToken.CollectionPublic} {
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{NonFungibleToken.CollectionPublic}>(self.CollectionPublicPath).borrow()!;
        return cpRef;
    }

    pub fun getOmniversePublic(addr: Address): &{OmniverseNFTCollectionPublic} {
        let pubAcct = getAccount(addr);
        let cpRef = pubAcct.getCapability<&{OmniverseNFTCollectionPublic}>(self.CollectionPublicPath).borrow()!;
        return cpRef;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // for signature verification
    pub fun getPublicKey(address: Address, signatureAlgorithm: SignatureAlgorithm): PublicKey {
        let pubAcct = getAccount(address);
        let pk = PublicKey(publicKey: pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey, 
                            signatureAlgorithm: signatureAlgorithm);
        return pk;
    }

    access(contract) fun addPublishedTx(pubKey: [UInt8], publishedTx: PublishedTx) {
        let pkStr = String.encodeHex(pubKey);
        if let rc = (&self.publishedRecorder[pkStr] as &RecordedCertificate?) {
            rc.addTx(tx: publishedTx);            
        } else {
            let rc = RecordedCertificate(addressOnFlow: publishedTx.oNFTProtocol.getOperateAddress());
            rc.addTx(tx: publishedTx); 
            self.publishedRecorder[pkStr] = rc;
        }
    }

    // Verify whether both the `pubAddr` and `rawData` are valid
    // `pubAddr` is the address of the message submitter, e.g. the off-chain router
    // So the `signature` is composited with: `pubAddr` + `self.nonce` + `rawData`
    access(contract) fun omniverseVerify(pubAddr: Address, rawData: [UInt8], signature: [UInt8], hashAlgorithm: HashAlgorithm): Bool {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pubKey.publicKey);
        
        var nonceV: UInt128 = 0;
        if let rc = self.publishedRecorder[pkStr] {
            nonceV = rc.getWorkingNonce();
        }
        
        let originData: [UInt8] = nonceV.toBigEndianBytes().concat(rawData);
        //log(String.encodeHex(rawData));
        //log(String.encodeHex(originData));
        //log(pubAddr);
        //log(String.encodeHex(pubAcct.keys.get(keyIndex: 0)!.publicKey.publicKey));
        //log(String.encodeHex(signature));

        if (pubKey.verify(signature: signature,
                        signedData: originData,
                        domainSeparationTag: "",
                        hashAlgorithm: hashAlgorithm)) {
            
            if let rc = (&self.publishedRecorder[pkStr] as &RecordedCertificate?) {
                rc.makeNextNonce();
            } else {
                let rc = RecordedCertificate(addressOnFlow: pubAddr);
                self.publishedRecorder[pkStr] = rc;
            }

            return true;
        } else {
            return false;
        }
    }

    pub fun getWorkingNonce(pubAddr: Address): UInt128 {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        let pkStr = String.encodeHex(pubKey.publicKey);
        if let rc = self.publishedRecorder[pkStr] {
            return rc.getWorkingNonce();
        } else {
            return 0;
        }
    }

    pub fun getOmniverseIdentity(pubAddr: Address): [UInt8] {
        let pubKey = self.getPublicKey(address: pubAddr, signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1);
        return pubKey.publicKey;
    }
}
 